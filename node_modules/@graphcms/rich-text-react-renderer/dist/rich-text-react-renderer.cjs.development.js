'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);
var richTextTypes = require('@graphcms/rich-text-types');
var escapeHtml = _interopDefault(require('escape-html'));

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function Audio(_ref) {
  var url = _ref.url;
  return React__default.createElement("audio", {
    style: {
      display: 'block',
      maxWidth: '100%',
      height: 'auto'
    },
    src: url,
    controls: true
  }, React__default.createElement("p", null, "Your browser doesn't support HTML5 audio. Here is a", ' ', React__default.createElement("a", {
    href: url
  }, "link to the audio"), " instead."));
}

/* eslint-disable jsx-a11y/iframe-has-title */
function IFrame(_ref) {
  var url = _ref.url;
  return React__default.createElement("div", {
    style: {
      position: 'relative',
      overflow: 'hidden',
      width: '100%',
      paddingTop: '56.25%'
    }
  }, React__default.createElement("iframe", {
    style: {
      position: 'absolute',
      top: 0,
      bottom: 0,
      right: 0,
      left: 0,
      width: '100%',
      height: '100%'
    },
    src: escapeHtml(url),
    loading: "lazy",
    allow: "fullscreen",
    frameBorder: "0",
    referrerPolicy: "no-referrer"
  }));
}

function Image(_ref) {
  var src = _ref.src,
      width = _ref.width,
      height = _ref.height,
      altText = _ref.altText,
      title = _ref.title;

  if ( !src) {
    console.warn("[@graphcms/rich-text-react-renderer]: src is required. You need to include a `url` in your query");
  }

  var shouldIncludeWidth = width && width > 0;
  var shouldIncludeHeight = height && height > 0;
  return React__default.createElement("img", Object.assign({
    loading: "lazy",
    src: escapeHtml(src)
  }, shouldIncludeWidth && {
    width: width
  }, shouldIncludeHeight && {
    height: height
  }, {
    alt: altText,
    title: title
  }));
}

function Video(_ref) {
  var src = _ref.src,
      width = _ref.width,
      height = _ref.height,
      title = _ref.title;
  return React__default.createElement("video", {
    src: escapeHtml(src),
    controls: true,
    width: width || '100%',
    height: height || '100%',
    title: title
  }, React__default.createElement("p", null, "Your browser doesn't support HTML5 video. Here is a", ' ', React__default.createElement("a", {
    href: src
  }, "link to the video"), " instead."));
}

function Class(_ref) {
  var className = _ref.className,
      children = _ref.children;
  return React__default.createElement("div", {
    className: className
  }, children);
}

function Link(_ref) {
  var children = _ref.children,
      rest = _objectWithoutPropertiesLoose(_ref, ["children"]);

  var href = rest.href,
      rel = rest.rel,
      id = rest.id,
      title = rest.title,
      openInNewTab = rest.openInNewTab,
      className = rest.className;
  var props = {};
  if (rel) props.rel = rel;
  if (id) props.id = id;
  if (title) props.title = title;
  if (className) props.className = className;
  if (openInNewTab) props.target = '_blank';
  return React__default.createElement("a", Object.assign({
    href: escapeHtml(href)
  }, props), children);
}

function FallbackForCustomAsset(_ref) {
  var mimeType = _ref.mimeType;

  {
    console.warn("[@graphcms/rich-text-react-renderer]: Unsupported mimeType encountered: " + mimeType + ". You need to write your renderer to render it since we are not opinionated about how this asset should be rendered (check our docs for more info).");
  }

  return React__default.createElement(React.Fragment, null);
}

var defaultElements = {
  a: Link,
  "class": Class,
  video: Video,
  img: Image,
  iframe: IFrame,
  blockquote: function blockquote(_ref2) {
    var children = _ref2.children;
    return React__default.createElement("blockquote", null, children);
  },
  ul: function ul(_ref3) {
    var children = _ref3.children;
    return React__default.createElement("ul", null, children);
  },
  ol: function ol(_ref4) {
    var children = _ref4.children;
    return React__default.createElement("ol", null, children);
  },
  li: function li(_ref5) {
    var children = _ref5.children;
    return React__default.createElement("li", null, children);
  },
  p: function p(_ref6) {
    var children = _ref6.children;
    return React__default.createElement("p", null, children);
  },
  h1: function h1(_ref7) {
    var children = _ref7.children;
    return React__default.createElement("h1", null, children);
  },
  h2: function h2(_ref8) {
    var children = _ref8.children;
    return React__default.createElement("h2", null, children);
  },
  h3: function h3(_ref9) {
    var children = _ref9.children;
    return React__default.createElement("h3", null, children);
  },
  h4: function h4(_ref10) {
    var children = _ref10.children;
    return React__default.createElement("h4", null, children);
  },
  h5: function h5(_ref11) {
    var children = _ref11.children;
    return React__default.createElement("h5", null, children);
  },
  h6: function h6(_ref12) {
    var children = _ref12.children;
    return React__default.createElement("h6", null, children);
  },
  table: function table(_ref13) {
    var children = _ref13.children;
    return React__default.createElement("table", null, children);
  },
  table_head: function table_head(_ref14) {
    var children = _ref14.children;
    return React__default.createElement("thead", null, children);
  },
  table_body: function table_body(_ref15) {
    var children = _ref15.children;
    return React__default.createElement("tbody", null, children);
  },
  table_row: function table_row(_ref16) {
    var children = _ref16.children;
    return React__default.createElement("tr", null, children);
  },
  table_cell: function table_cell(_ref17) {
    var children = _ref17.children;
    return React__default.createElement("td", null, children);
  },
  table_header_cell: function table_header_cell(_ref18) {
    var children = _ref18.children;
    return React__default.createElement("th", null, children);
  },
  bold: function bold(_ref19) {
    var children = _ref19.children;
    return React__default.createElement("b", null, children);
  },
  italic: function italic(_ref20) {
    var children = _ref20.children;
    return React__default.createElement("i", null, children);
  },
  underline: function underline(_ref21) {
    var children = _ref21.children;
    return React__default.createElement("u", null, children);
  },
  code: function code(_ref22) {
    var children = _ref22.children;
    return React__default.createElement("code", null, children);
  },
  code_block: function code_block(_ref23) {
    var children = _ref23.children;
    return React__default.createElement("pre", {
      style: {
        whiteSpace: 'pre',
        wordWrap: 'break-word',
        overflowX: 'auto',
        WebkitOverflowScrolling: 'touch',
        fontFamily: 'monospace'
      }
    }, children);
  },
  list_item_child: function list_item_child(_ref24) {
    var children = _ref24.children;
    return React__default.createElement(React__default.Fragment, null, children);
  },
  Asset: {
    audio: function audio(props) {
      return React__default.createElement(Audio, Object.assign({}, props, {
        url: props.url
      }));
    },
    image: function image(props) {
      return React__default.createElement(Image, Object.assign({}, props, {
        src: props.url
      }));
    },
    video: function video(props) {
      return React__default.createElement(Video, Object.assign({}, props, {
        src: props.url
      }));
    },
    font: FallbackForCustomAsset,
    application: FallbackForCustomAsset,
    model: FallbackForCustomAsset,
    text: FallbackForCustomAsset
  },
  embed: {},
  link: {}
};

function serialize(text) {
  if (text.includes('\n')) {
    var splitText = text.split('\n');
    return splitText.map(function (line, index) {
      return React__default.createElement(React__default.Fragment, {
        key: index
      }, line, index === splitText.length - 1 ? null : React__default.createElement("br", null));
    });
  }

  return text;
}

function RenderText(_ref) {
  var textNode = _ref.textNode,
      renderers = _ref.renderers,
      shouldSerialize = _ref.shouldSerialize;
  var text = textNode.text,
      bold = textNode.bold,
      italic = textNode.italic,
      underline = textNode.underline,
      code = textNode.code;
  var parsedText = shouldSerialize ? serialize(text) : text;
  var Bold = renderers == null ? void 0 : renderers['bold'];
  var Italic = renderers == null ? void 0 : renderers['italic'];
  var Underline = renderers == null ? void 0 : renderers['underline'];
  var Code = renderers == null ? void 0 : renderers['code'];

  if (bold && Bold) {
    parsedText = React__default.createElement(Bold, null, parsedText);
  }

  if (italic && Italic) {
    parsedText = React__default.createElement(Italic, null, parsedText);
  }

  if (underline && Underline) {
    parsedText = React__default.createElement(Underline, null, parsedText);
  }

  if (code && Code) {
    parsedText = React__default.createElement(Code, null, parsedText);
  }

  return React__default.createElement(React__default.Fragment, null, parsedText);
}

function getArrayOfElements(content) {
  return Array.isArray(content) ? content : content.children;
}

function RenderNode(_ref) {
  var node = _ref.node,
      parent = _ref.parent,
      renderers = _ref.renderers,
      references = _ref.references;

  if (richTextTypes.isText(node)) {
    var text = node.text;
    var shouldSerialize = parent && richTextTypes.isElement(parent) && parent.type !== 'code-block';
    return React__default.createElement(RenderText, {
      textNode: _extends({}, node, {
        text: text
      }),
      renderers: renderers,
      shouldSerialize: shouldSerialize
    });
  }

  if (richTextTypes.isElement(node)) {
    return React__default.createElement(RenderElement, {
      element: node,
      renderers: renderers,
      references: references
    });
  }

  var type = node.type;

  {
    console.warn("[@graphcms/rich-text-react-renderer]: Unknown node type encountered: " + type);
  }

  return React__default.createElement(React.Fragment, null);
}

function RenderElement(_ref2) {
  var element = _ref2.element,
      renderers = _ref2.renderers,
      references = _ref2.references;

  var children = element.children,
      type = element.type,
      rest = _objectWithoutPropertiesLoose(element, ["children", "type"]);

  var nodeId = rest.nodeId,
      nodeType = rest.nodeType; // Checks if the element is empty so that it can be removed.

  if (type in richTextTypes.EmptyElementsToRemove && richTextTypes.isEmpty({
    children: children
  })) {
    return React__default.createElement(React.Fragment, null);
  }

  var isEmbed = nodeId && nodeType;
  /**
   * The .filter method returns an array with all elements found.
   * Since there won't be duplicated ID's, it's safe to use the first element.
   */

  var referenceValues = isEmbed ? references == null ? void 0 : references.filter(function (ref) {
    return ref.id === nodeId;
  })[0] : null;
  /**
   * `id` is used to correctly find the props for the reference.
   * If it's not present, we show an error and render a Fragment.
   */

  if ( isEmbed && !(referenceValues != null && referenceValues.id)) {
    console.error("[@graphcms/rich-text-react-renderer]: No id found for embed node " + nodeId + ". In order to render custom embeds, `id` is required in your reference query.");
    return React__default.createElement(React.Fragment, null);
  }
  /**
   * `mimeType` is used to determine if the node is an image or a video.
   * That's why this is required and we show an error if it's not present.
   * Only for custom assets embeds.
   */


  if ( isEmbed && nodeType === 'Asset' && !(referenceValues != null && referenceValues.mimeType)) {
    console.error("[@graphcms/rich-text-react-renderer]: No mimeType found for embed node " + nodeId + ". In order to render custom assets, `mimeType` is required in your reference query.");
    return React__default.createElement(React.Fragment, null);
  }
  /**
   * `url` is needed to correctly render the image, video, audio or any other asset
   * Only for custom assets embeds.
   */


  if ( isEmbed && nodeType === 'Asset' && !(referenceValues != null && referenceValues.url)) {
    console.error("[@graphcms/rich-text-react-renderer]: No url found for embed node " + nodeId + ". In order to render custom assets, `url` is required in your reference query.");
    return React__default.createElement(React.Fragment, null);
  }
  /**
   * There's two options if the element is an embed.
   * 1. If it isn't an asset, then we simply try to use the renderer for that model.
   *  1.1 If we don't find a renderer, we render a Fragment and show a warning.
   * 2. If it is an asset, then:
   *  2.1 If we have a custom renderer for that specific mimeType, we use it.
   *  2.2 If we don't have, we use the default mimeType group renderer (application, image, video...).
   */


  var elementToRender; // Option 1

  if (isEmbed && nodeType !== 'Asset') {
    var _renderers$link, _renderers$embed;

    var _element = type === 'link' ? renderers == null ? void 0 : (_renderers$link = renderers.link) == null ? void 0 : _renderers$link[nodeType] : renderers == null ? void 0 : (_renderers$embed = renderers.embed) == null ? void 0 : _renderers$embed[nodeType];

    if (_element !== undefined) {
      elementToRender = _element;
    } else {
      // Option 1.1
      console.warn("[@graphcms/rich-text-react-renderer]: No renderer found for custom " + type + " nodeType " + nodeType + ".");
      return React__default.createElement(React.Fragment, null);
    }
  } // Option 2


  if (isEmbed && nodeType === 'Asset') {
    var _renderers$Asset;

    var _element2 = renderers == null ? void 0 : (_renderers$Asset = renderers.Asset) == null ? void 0 : _renderers$Asset[referenceValues == null ? void 0 : referenceValues.mimeType]; // Option 2.1


    if (_element2 !== undefined) {
      elementToRender = _element2;
    } else {
      var _renderers$Asset2;

      // Option 2.2
      var mimeTypeGroup = referenceValues == null ? void 0 : referenceValues.mimeType.split('/')[0];
      elementToRender = renderers == null ? void 0 : (_renderers$Asset2 = renderers.Asset) == null ? void 0 : _renderers$Asset2[mimeTypeGroup];
    }
  }

  var elementNodeRenderer = isEmbed ? elementToRender : renderers == null ? void 0 : renderers[richTextTypes.elementTypeKeys[type]];
  var NodeRenderer = elementNodeRenderer;

  var props = _extends({}, rest, referenceValues);

  if (NodeRenderer) {
    return React__default.createElement(NodeRenderer, Object.assign({}, props), React__default.createElement(RenderElements, {
      content: children,
      renderers: renderers,
      references: references,
      parent: element
    }));
  }

  return React__default.createElement(React.Fragment, null);
}

function RenderElements(_ref3) {
  var content = _ref3.content,
      references = _ref3.references,
      renderers = _ref3.renderers,
      parent = _ref3.parent;
  var elements = getArrayOfElements(content);
  return React__default.createElement(React__default.Fragment, null, elements.map(function (node, index) {
    return React__default.createElement(RenderNode, {
      node: node,
      parent: parent || null,
      renderers: renderers,
      references: references,
      key: index
    });
  }));
}

function RichText(_ref4) {
  var content = _ref4.content,
      resolvers = _ref4.renderers,
      references = _ref4.references;

  // Shallow merge doensn't work here because if we spread over the elements, the
  // Asset object will be completly overriden by the resolvers. We need to keep
  // the default elements for the Asset that hasn't been writen.
  var assetRenderers = _extends({}, defaultElements == null ? void 0 : defaultElements.Asset, resolvers == null ? void 0 : resolvers.Asset);

  var renderers = _extends({}, defaultElements, resolvers, {
    Asset: assetRenderers
  });

  if ( !content) {
    console.error("[@graphcms/rich-text-react-renderer]: content is required.");
    return React__default.createElement(React.Fragment, null);
  }

  if ( !Array.isArray(content) && !content.children) {
    console.error("[@graphcms/rich-text-react-renderer]: children is required in content.");
    return React__default.createElement(React.Fragment, null);
  }
  /*
    Checks if there's a embed type inside the content and if the `references` prop is defined
       If it isn't defined and there's embed elements, it will show a warning
    */


  {
    var elements = getArrayOfElements(content);
    var embedElements = elements.filter(function (element) {
      return element.type === 'embed';
    });

    if (embedElements.length > 0 && !references) {
      console.warn("[@graphcms/rich-text-react-renderer]: to render embed elements you need to provide the `references` prop");
    }
  }

  return React__default.createElement(RenderElements, {
    content: content,
    renderers: renderers,
    references: references
  });
}

exports.RichText = RichText;
//# sourceMappingURL=rich-text-react-renderer.cjs.development.js.map
